# Build {{ system_name }} - Complete System

## System Overview
{{ system_purpose }}

{% if tech_stack %}
## Tech Stack
- **Primary Language**: {{ tech_stack.language }}
- **Framework**: {{ tech_stack.framework }}
- **Architecture**: {{ tech_stack.architecture | default('Modular components') }}
- **Key Libraries**: {{ tech_stack.libraries | join(', ') }}
- **Database**: {{ tech_stack.database | default('File-based storage') }}
{% endif %}

## System Architecture

### Containers
{% for container in containers %}
- **{{ container.name }}**: {{ container.description }}
  - Technology: {{ container.technology | join(', ') if container.technology is iterable else container.technology }}
  - Purpose: {{ container.responsibilities | join(', ') if container.responsibilities is iterable else container.responsibilities }}
{% endfor %}

### Components
{% for component in components %}
- **{{ component.name }}**: {{ component.description }}
  {% if component.dependencies %}
  - Depends on: {{ component.dependencies | join(', ') }}
  {% endif %}
{% endfor %}

## Build Strategy

### 1. Foundation First
Start with the core infrastructure:
- Set up {{ tech_stack.language if tech_stack else 'the main' }} project structure
- Implement file storage and configuration loading
- Create basic CLI framework

### 2. Core Components
Build components in dependency order:
{% for component in build_order %}
- **{{ component.name }}** ({{ component.priority }})
  - Why this order: {{ component.reason }}
{% endfor %}

### 3. Integration & Testing
- Connect all components through the main application
- Implement end-to-end user flows
- Add comprehensive error handling

## Critical Integration Points

{% for flow in key_flows %}
### {{ flow.name | title }}
**Trigger**: {{ flow.trigger }}  
**Expected Outcome**: {{ flow.outcome }}  
**Components Involved**: {{ flow.involves | join(' → ') if flow.involves is iterable else flow.involves }}
{% endfor %}

## System-Wide Requirements

### Error Handling Strategy
- All components must handle failures gracefully
- Consistent error messaging across the system
- Proper logging for debugging and monitoring

### Configuration Management
- Single configuration file for system settings
- Environment-specific overrides
- Validation of all configuration on startup

### Performance Targets
- System startup: {{ performance.startup_time | default('<2s') }}
- Command response: {{ performance.response_time | default('<500ms') }}
- Memory usage: {{ performance.memory_limit | default('<100MB') }}

## Success Criteria

### Functional Requirements
- All user commands work end-to-end
- Error scenarios handled gracefully
- System recovers from component failures

### Quality Requirements
- Code follows established patterns
- Comprehensive test coverage
- Clear documentation and examples

---

**📋 Complete Specifications**: All component and container specs are attached. Review the `data_flows` sections to understand component interactions.

**🎯 Implementation Focus**: 
1. Start with `{{ main_container }}` container
2. Build components incrementally and test each one
3. Focus on the `{{ primary_flow }}` user flow first
4. Refer to individual component specs for detailed requirements

**⚠️ Critical**: Pay special attention to error handling patterns - they're consistent across all components and define the system's reliability.