# Python Implementation for {{ component_name }}

## Purpose
{{ purpose_statement }}

## Class Structure

### Main Class Definition
```python
from typing import Optional, List, Dict, Any, Union
from dataclasses import dataclass
from enum import Enum
import logging
{% if api_dependencies %}
import asyncio
import aiohttp
{% endif %}
{% if failure_modes %}
from contextlib import contextmanager
{% endif %}

{% if component_states %}
class {{ component_name.replace(' ', '') }}State(Enum):
    {% for state in component_states %}
    {{ state.upper() }} = "{{ state }}"
    {% endfor %}
{% endif %}

{% if data_captured or data_displayed %}
@dataclass
class {{ component_name.replace(' ', '') }}Data:
    {% if data_captured %}
    # Data to capture: {{ data_captured }}
    captured_data: Dict[str, Any]
    {% endif %}
    {% if data_displayed %}
    # Data to display: {{ data_displayed }}
    display_data: Dict[str, Any]
    {% endif %}
    timestamp: Optional[str] = None
{% endif %}

class {{ component_name.replace(' ', '') }}:
    """{{ purpose_statement }}"""
    
    def __init__(self{% if api_dependencies %}, session: Optional[aiohttp.ClientSession] = None{% endif %}):
        {% if component_states %}
        self._state = {{ component_name.replace(' ', '') }}State.{{ component_states[0].upper() }}
        {% endif %}
        self._logger = logging.getLogger(__name__)
        {% if api_dependencies %}
        self._session = session
        {% endif %}
        {% if data_captured or data_displayed %}
        self._data = {{ component_name.replace(' ', '') }}Data({}, {})
        {% endif %}
        {% if failure_modes %}
        self._error_count = 0
        self._last_error: Optional[Exception] = None
        {% endif %}
```

## Core Interface Implementation

{% for interface in interfaces %}
### {{ interface.name | title }} Method
```python
{% if 'async' in interface.name or api_dependencies %}async {% endif %}def {{ interface.name | snake_case }}(self, input_data: {{ interface.input | default('Any') }}) -> {{ interface.output | default('Any') }}:
    """
    {{ interface.description | default('Implements ' + interface.name + ' functionality') }}
    
    Args:
        input_data: {{ interface.input | default('Input data for the operation') }}
        
    Returns:
        {{ interface.output | default('Result of the operation') }}
        
    Raises:
        ValueError: If input_data is invalid
        {% for mode in failure_modes %}
        {{ mode.type | title }}Error: If {{ mode.type }} occurs
        {% endfor %}
    """
    self._logger.info(f"Starting {{ interface.name }} with input: {input_data}")
    
    try:
        # Validate input
        self._validate_input(input_data)
        
        {% if component_states %}
        # Update state
        self._state = {{ component_name.replace(' ', '') }}State.PROCESSING
        {% endif %}
        
        # Core implementation
        result = {% if 'async' in interface.name or api_dependencies %}await {% endif %}self._execute_{{ interface.name | snake_case }}(input_data)
        
        {% if component_states %}
        # Update state on success
        self._state = {{ component_name.replace(' ', '') }}State.SUCCESS
        {% endif %}
        
        self._logger.info(f"{{ interface.name }} completed successfully")
        return result
        
    except Exception as e:
        {% if failure_modes %}
        self._handle_error(e, "{{ interface.name }}")
        {% endif %}
        {% if component_states %}
        self._state = {{ component_name.replace(' ', '') }}State.ERROR
        {% endif %}
        raise

{% if 'async' in interface.name or api_dependencies %}async {% endif %}def _execute_{{ interface.name | snake_case }}(self, input_data: Any) -> Any:
    """Internal implementation of {{ interface.name }}"""
    # TODO: Implement core logic here
    pass
{% endfor %}

## Data Validation

```python
def _validate_input(self, data: Any) -> None:
    """Validate input data"""
    if data is None:
        raise ValueError("Input data cannot be None")
    
    {% if data_validation %}
    # {{ data_validation }}
    {% endif %}
    
    # Additional validation logic here
    pass

{% if data_captured %}
def _validate_captured_data(self, data: Dict[str, Any]) -> bool:
    """Validate captured data format"""
    required_fields = [/* Define required fields based on {{ data_captured }} */]
    return all(field in data for field in required_fields)
{% endif %}
```

## State Management

{% if component_states %}
```python
@property
def current_state(self) -> {{ component_name.replace(' ', '') }}State:
    """Get current component state"""
    return self._state

def _transition_to_state(self, new_state: {{ component_name.replace(' ', '') }}State) -> None:
    """Safely transition to new state"""
    valid_transitions = {
        {% for state in component_states %}
        {{ component_name.replace(' ', '') }}State.{{ state.upper() }}: [
            # Define valid transitions from {{ state }}
        ],
        {% endfor %}
    }
    
    if new_state not in valid_transitions.get(self._state, []):
        raise ValueError(f"Invalid state transition from {self._state} to {new_state}")
    
    old_state = self._state
    self._state = new_state
    self._logger.debug(f"State transition: {old_state} -> {new_state}")

{% for state in component_states %}
def is_{{ state }}(self) -> bool:
    """Check if component is in {{ state }} state"""
    return self._state == {{ component_name.replace(' ', '') }}State.{{ state.upper() }}
{% endfor %}
```
{% endif %}

## Error Handling

{% for mode in failure_modes %}
```python
class {{ mode.type | title | replace(' ', '') }}Error(Exception):
    """{{ mode.impact }}"""
    pass
```
{% endfor %}

```python
def _handle_error(self, error: Exception, context: str) -> None:
    """Central error handling"""
    self._error_count += 1
    self._last_error = error
    
    error_msg = f"Error in {context}: {str(error)}"
    self._logger.error(error_msg, exc_info=True)
    
    {% for mode in failure_modes %}
    {% if mode.recovery %}
    # {{ mode.type }} recovery: {{ mode.recovery }}
    if isinstance(error, {{ mode.type | title | replace(' ', '') }}Error):
        self._recover_from_{{ mode.type | snake_case }}()
    {% endif %}
    {% endfor %}

{% for mode in failure_modes %}
{% if mode.recovery %}
def _recover_from_{{ mode.type | snake_case }}(self) -> None:
    """Recovery strategy for {{ mode.type }}"""
    self._logger.info("Attempting recovery from {{ mode.type }}")
    # {{ mode.recovery }}
    # Implementation here
{% endif %}
{% endfor %}

@contextmanager
def _error_context(self, operation: str):
    """Context manager for error handling"""
    try:
        yield
    except Exception as e:
        self._handle_error(e, operation)
        raise
```

## External Dependencies

{% if api_dependencies %}
```python
{% for dep in api_dependencies %}
async def _call_{{ dep.name | snake_case }}(self, data: Any) -> Any:
    """Call {{ dep.name }} external service"""
    if not self._session:
        raise ValueError("HTTP session not configured")
    
    try:
        # {{ dep.purpose }}
        async with self._session.post(
            "{{ dep.endpoint | default('/api/endpoint') }}",
            json=data,
            timeout=aiohttp.ClientTimeout(total={{ dep.timeout | default('30') }})
        ) as response:
            response.raise_for_status()
            return await response.json()
            
    except aiohttp.ClientError as e:
        {% if dep.fallback %}
        self._logger.warning(f"{{ dep.name }} failed, using fallback: {e}")
        return self._{{ dep.fallback | snake_case }}_fallback(data)
        {% else %}
        raise {{ dep.name | title }}Error(f"Failed to call {{ dep.name }}: {e}")
        {% endif %}

{% if dep.fallback %}
def _{{ dep.fallback | snake_case }}_fallback(self, data: Any) -> Any:
    """Fallback implementation for {{ dep.name }}"""
    # {{ dep.fallback }}
    # Implementation here
    pass
{% endif %}
{% endfor %}
```
{% endif %}

## Monitoring and Observability

```python
def get_health_status(self) -> Dict[str, Any]:
    """Get component health status"""
    return {
        "status": "healthy" if self._error_count < 5 else "degraded",
        {% if component_states %}
        "current_state": self._state.value,
        {% endif %}
        "error_count": self._error_count,
        "last_error": str(self._last_error) if self._last_error else None,
        {% if api_dependencies %}
        "dependencies": self._check_dependencies(),
        {% endif %}
    }

{% if monitoring_requirements %}
def get_metrics(self) -> Dict[str, Any]:
    """Get component metrics"""
    return {
        {% for metric in monitoring_requirements %}
        "{{ metric | snake_case }}": self._get_{{ metric | snake_case }}(),
        {% endfor %}
    }

{% for metric in monitoring_requirements %}
def _get_{{ metric | snake_case }}(self) -> float:
    """Get {{ metric }} metric"""
    # Implementation for {{ metric }}
    return 0.0
{% endfor %}
{% endif %}

{% if api_dependencies %}
async def _check_dependencies(self) -> Dict[str, bool]:
    """Check external dependency health"""
    results = {}
    {% for dep in api_dependencies %}
    try:
        # Health check for {{ dep.name }}
        async with self._session.get("{{ dep.health_endpoint | default('/health') }}") as response:
            results["{{ dep.name }}"] = response.status == 200
    except Exception:
        results["{{ dep.name }}"] = False
    {% endfor %}
    return results
{% endif %}
```

## Testing Support

```python
# test_{{ component_name | snake_case }}.py
import pytest
import asyncio
from unittest.mock import Mock, patch

class Test{{ component_name.replace(' ', '') }}:
    
    def setup_method(self):
        {% if api_dependencies %}
        self.mock_session = Mock()
        self.component = {{ component_name.replace(' ', '') }}(session=self.mock_session)
        {% else %}
        self.component = {{ component_name.replace(' ', '') }}()
        {% endif %}
    
    {% for interface in interfaces %}
    {% if 'async' in interface.name or api_dependencies %}@pytest.mark.asyncio
    async {% endif %}def test_{{ interface.name | snake_case }}_success(self):
        """Test {{ interface.name }} successful execution"""
        # Arrange
        test_input = {}  # Define test input
        expected_output = {}  # Define expected output
        
        # Act
        result = {% if 'async' in interface.name or api_dependencies %}await {% endif %}self.component.{{ interface.name | snake_case }}(test_input)
        
        # Assert
        assert result == expected_output
        {% if component_states %}
        assert self.component.current_state == {{ component_name.replace(' ', '') }}State.SUCCESS
        {% endif %}
    
    {% if 'async' in interface.name or api_dependencies %}@pytest.mark.asyncio
    async {% endif %}def test_{{ interface.name | snake_case }}_error_handling(self):
        """Test {{ interface.name }} error handling"""
        # Test error scenarios
        with pytest.raises(ValueError):
            {% if 'async' in interface.name or api_dependencies %}await {% endif %}self.component.{{ interface.name | snake_case }}(None)
    {% endfor %}
    
    {% for mode in failure_modes %}
    def test_{{ mode.type | snake_case }}_handling(self):
        """Test {{ mode.type }} error handling"""
        # Test {{ mode.type }} scenario
        pass
    {% endfor %}
    
    {% if edge_cases %}
    {% for case in edge_cases %}
    def test_edge_case_{{ case.name | snake_case }}(self):
        """Test {{ case.name }} edge case"""
        # {{ case.scenario }}
        # Test implementation
        pass
    {% endfor %}
    {% endif %}
```

## Usage Example

```python
{% if api_dependencies %}
async def main():
    async with aiohttp.ClientSession() as session:
        component = {{ component_name.replace(' ', '') }}(session=session)
        
        {% for interface in interfaces %}
        # Use {{ interface.name }}
        result = await component.{{ interface.name | snake_case }}(test_data)
        print(f"{{ interface.name }} result: {result}")
        {% endfor %}
        
        # Check health
        health = component.get_health_status()
        print(f"Health: {health}")

if __name__ == "__main__":
    asyncio.run(main())
{% else %}
def main():
    component = {{ component_name.replace(' ', '') }}()
    
    {% for interface in interfaces %}
    # Use {{ interface.name }}
    result = component.{{ interface.name | snake_case }}(test_data)
    print(f"{{ interface.name }} result: {result}")
    {% endfor %}
    
    # Check health
    health = component.get_health_status()
    print(f"Health: {health}")

if __name__ == "__main__":
    main()
{% endif %}
```

## Implementation Checklist

### Core Functionality
- [ ] All interfaces implemented
{% for interface in interfaces %}
- [ ] {{ interface.name }} method working correctly
{% endfor %}
- [ ] Input validation implemented
- [ ] Output format matches specification

### Error Handling
{% for mode in failure_modes %}
- [ ] {{ mode.type }} handled gracefully
{% endfor %}
- [ ] Proper logging implemented
- [ ] Error recovery mechanisms in place

### State Management
{% if component_states %}
{% for state in component_states %}
- [ ] {{ state }} state handled correctly
{% endfor %}
- [ ] State transitions validated
{% endif %}

### Testing
- [ ] Unit tests for all methods
- [ ] Error scenario tests
- [ ] Edge case tests
- [ ] Integration tests
{% if api_dependencies %}
- [ ] Mock external dependencies
{% endif %}

### Performance
{% if performance_requirements %}
{% for req in performance_requirements %}
- [ ] {{ req.metric }} meets {{ req.target }}
{% endfor %}
{% endif %}
- [ ] Async operations where appropriate
- [ ] Resource cleanup implemented

---
*Python implementation guide generated by SpecPlane*