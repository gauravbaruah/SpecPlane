meta:
  id: "coverage_assessor"
  name: "Coverage Assessor"
  version: "0.1.0"
  type: "component"
  level: "component"
  purpose: "Evaluates design completeness and identifies critical gaps before implementation"
  status: "prototype"

contracts:
  interfaces:
    - name: "assess_coverage"
      input: "AnsweredQuestions + ComponentType"
      output: "CoverageReport"
      logic: "systematic_completeness_check + gap_identification + scoring"
      
    - name: "calculate_score"
      input: "AnsweredQuestions + WeightingRules"
      output: "CoverageScore"
      logic: "weighted_scoring + critical_section_validation"
      
    - name: "identify_gaps"
      input: "ComponentSpec + RequiredSections"
      output: "Gap[]"
      logic: "pattern_matching + requirement_validation + priority_ranking"
      
    - name: "suggest_improvements"
      input: "CoverageReport + ComponentType"
      output: "Recommendation[]"
      logic: "gap_analysis + best_practice_matching + actionable_suggestions"

  assessment_framework:
    required_sections:
      all_components: ["purpose", "basic_interfaces", "dependencies"]
      storage_components: ["error_handling", "backup_strategy", "data_integrity"]
      ui_components: ["states", "user_interactions", "accessibility_notes"]
      api_components: ["error_codes", "authentication", "rate_limits"]
      ai_components: ["safety_guardrails", "fallback_strategies", "cost_constraints"]
      
    scoring_weights:
      purpose_clarity: 25%
      failure_mode_coverage: 20%
      interface_completeness: 15%
      dependency_mapping: 10%
      constraint_definition: 10%
      observability_planning: 10%
      implementation_readiness: 10%

    gap_severity:
      critical: "blocks_implementation"
      important: "reduces_quality_significantly" 
      moderate: "impacts_maintainability"
      minor: "nice_to_have_improvement"

prototype_modes:
  p0_simple:
    assessment_method: "basic_section_completion"
    scoring_algorithm: "simple_percentage"
    gap_detection: "missing_required_only"
    total_possible_score: 100
    
  p1_smart:
    assessment_method: "weighted_section_analysis"
    scoring_algorithm: "weighted_percentage + penalties"
    gap_detection: "pattern_based + missing_sections"
    contextual_adjustments: true
    
  p2_dynamic:
    assessment_method: "intelligent_quality_analysis"
    scoring_algorithm: "ml_based_scoring + human_feedback"
    gap_detection: "semantic_analysis + predictive_gaps"
    continuous_learning: true

data:
  assessment_rules:
    source: "config/assessment_rules.yaml"
    schema: "AssessmentRule"
    
  gap_patterns:
    source: "config/gap_patterns.yaml" 
    schema: "GapPattern"
    examples:
      storage_without_backup:
        pattern: "storage_component && !backup_strategy"
        severity: "critical"
        recommendation: "Add backup and recovery procedures"
        
      ui_missing_states:
        pattern: "ui_component && states.length < 3"
        severity: "important"
        recommendation: "Define loading, error, and empty states"
        
      api_no_auth:
        pattern: "api_component && !authentication"
        severity: "critical"
        recommendation: "Specify authentication mechanism"

coverage_calculation:
  basic_scoring:
    method: |
      score = (answered_questions / total_questions) * 100
      
  weighted_scoring:
    method: |
      score = sum(section_weight * section_completeness) 
      penalties = critical_gaps * 10 + important_gaps * 5
      final_score = max(0, score - penalties)

data_flows:
  - name: "complete_coverage_assessment"
    sequence: |
      sequenceDiagram
        participant CA as Coverage_Assessor
        participant FS as File_Storage
        participant PL as Pattern_Library
        
        CA->>FS: load("assessment_rules.yaml")
        CA->>FS: load("gap_patterns.yaml")
        CA->>CA: analyze_completeness(answers)
        CA->>PL: check_component_patterns(type)
        CA->>CA: calculate_weighted_score()
        CA->>CA: identify_critical_gaps()
        CA-->>CA: generate_recommendations()

dependencies:
  internal:
    - "Pattern_Library"  # For pattern-based gap detection
    - "File_Storage"     # For assessment rules and templates
  external: []

constraints:
  performance:
    assessment_time: "<2s"
    gap_detection_time: "<1s"
    
  quality:
    gap_detection_accuracy: ">90%"
    false_positive_rate: "<5%"
    recommendation_relevance: ">85%"

error_handling:
  missing_assessment_rules:
    action: "use_default_rules + log_warning"
    
  invalid_component_type:
    action: "fallback_to_generic_assessment"
    
  scoring_calculation_error:
    action: "manual_scoring_fallback + error_report"

observability:
  metrics:
    - "assessments_completed_per_day"
    - "average_coverage_score"
    - "gap_detection_accuracy"
    - "recommendation_acceptance_rate"
    
  events:
    - "coverage.assessment.started"
    - "coverage.score.calculated"
    - "coverage.gaps.identified"
    - "coverage.recommendations.generated"

# Example assessment output
example_outputs:
  basic_assessment:
    component_name: "file_storage"
    coverage_score: 85
    sections_completed: ["purpose", "interfaces", "error_handling"]
    sections_missing: ["observability", "performance_constraints"]
    
  detailed_assessment:
    component_name: "user_authentication"
    coverage_score: 72
    gaps:
      critical: ["missing_rate_limiting", "no_password_policy"]
      important: ["incomplete_error_handling", "missing_audit_logs"]
      moderate: ["basic_monitoring_only"]
    recommendations:
      - "Add rate limiting to prevent brute force attacks"
      - "Define password complexity requirements"
      - "Implement comprehensive error response codes"


tests:
  acceptance:
    - "Empty answers object returns coverage_score: 0"
    - "All required questions answered returns coverage_score >= 70"
    - "Missing storage backup_strategy triggers critical gap warning"
    - "UI component without states triggers important gap warning"
    - "Gap recommendations include specific actionable text"
    - "Assessment completes in <2s for typical component (15 questions)"

validation_scenarios:
  storage_component:
    input: {component_type: "storage", backup_strategy: null}
    expected_gaps: ["critical: missing_backup_strategy"]
    expected_recommendation: "Add backup and recovery procedures with testing plan"
    
  complete_component:
    input: {all_required_sections: present}
    expected_score: ">= 85"
    expected_gaps: []


observability:
  automated_metrics:
    - name: "coverage_score_distribution"
      measurement: "histogram of all assessment scores"
      
    - name: "gap_detection_accuracy"  
      measurement: "automated validation against known test cases"
      
    - name: "assessment_completion_time"
      measurement: "time from input to output"
      
  human_metrics:
    - name: "recommendation_usefulness"
      measurement: "human rating 1-5 scale"
      collection: "post-session survey"
      frequency: "10% of sessions"
      
    - name: "question_clarity"
      measurement: "human rating 1-5 scale"  
      collection: "embedded in interview flow"
      question: "Was this question clear and actionable?"
      
    - name: "generated_spec_quality"
      measurement: "human assessment of output quality"
      collection: "follow-up email after 1 week"
      frequency: "5% of sessions"
      
  metric_collection:
    automated_pipeline:
      - "Events logged to .specplane/logs/events.jsonl"
      - "Metrics aggregated to .specplane/logs/metrics.json daily"
      - "Dashboard generated from metrics.json weekly"
      
    human_feedback:
      - "Rating prompts embedded in CLI at natural breakpoints"
      - "Optional feedback survey at session completion"
      - "Follow-up quality assessment via email (if provided)"